# 認知研究報告：Claude Code 工作方法論與思維框架

**研究員視角**：認知研究員
**研究日期**：2026-01-26
**資料來源**：Claude Code 官方文檔、工作流程研究、TASKS 階段設計方案

---

## 摘要

Claude Code 的工作方法論建立在**漸進式資訊處理**和**多層次抽象管理**的認知原則上。計畫模式通過限制工具權限降低認知負荷，專注於分析與理解；問題解決採用**廣度優先探索**策略，從全域視角逐步縮小至具體實現；程式碼庫學習遵循**概覽先行原則**，建立心智模型後再深入細節。這些方法論共同形成了一套適應複雜軟體開發任務的認知框架，強調在正確的抽象層級執行正確的認知任務。

---

## 計畫模式分析

### 認知優勢

#### 1. 認知負荷管理
計畫模式通過**工具限制**創造了一個純分析環境，降低了決策複雜度：

- **執行焦慮消除**：無需同時思考「理解」與「執行」，專注於分析層
- **錯誤成本降低**：唯讀操作消除了「做錯事」的心理負擔
- **工作記憶優化**：不必追蹤檔案變更狀態，釋放認知資源用於理解

#### 2. 元認知支持
計畫模式鼓勵**先思考再行動**的元認知策略：

```
認知流程對比：

實作模式：理解 → 行動 → 驗證 → 調整（快速循環）
計畫模式：理解 → 規劃 → 驗證計畫 → 執行（深思熟慮）
```

計畫模式在**執行前**強制進行完整的心智模擬，提高決策品質。

#### 3. 抽象層級維持
計畫模式防止**過早具體化**：

- 保持在戰略/戰術層，避免陷入實作細節
- 適合進行架構級思考和多步驟規劃
- 防止「看到程式碼就想改」的衝動反應

### 適用情境

| 情境類型 | 認知需求 | 計畫模式優勢 |
|---------|---------|-------------|
| **多步驟實現** | 全域視角、依賴管理 | 避免局部最佳化，看見系統性影響 |
| **程式碼探索** | 模式識別、架構理解 | 專注於「是什麼」而非「怎麼改」 |
| **互動式開發** | 方案比較、權衡分析 | 低成本探索多個可能性 |
| **複雜除錯** | 根因分析、假設驗證 | 系統性追蹤執行流，避免試錯 |
| **重構規劃** | 影響評估、風險分析 | 完整模擬變更影響再執行 |

### 與實作模式的切換

#### 切換時機認知模型

```
┌─────────────────────────────────────────────────────┐
│  認知任務類型決策樹                                  │
├─────────────────────────────────────────────────────┤
│                                                      │
│  問題性質？                                          │
│     │                                                │
│     ├─ 理解性（What/Why）→ 計畫模式                 │
│     │   ├─ 這個系統如何運作？                       │
│     │   ├─ 為什麼會有這個錯誤？                     │
│     │   └─ 有哪些可能的解決方案？                   │
│     │                                                │
│     └─ 執行性（How/Do）→ 實作模式                   │
│         ├─ 實作這個函數                             │
│         ├─ 修復這個 bug                             │
│         └─ 新增這個功能                             │
│                                                      │
└─────────────────────────────────────────────────────┘
```

#### 模式切換的認知成本

- **計畫 → 實作**：低成本（已有心智模型，直接執行）
- **實作 → 計畫**：中等成本（需暫停執行，重建全域視角）
- **頻繁切換**：高成本（破壞工作流，增加認知摩擦）

**最佳實踐**：在同一階段內保持模式穩定，完成認知任務後再切換。

---

## 問題解決框架

### 由廣入窄策略

#### 認知原理：廣度優先搜索（BFS）

Claude Code 採用 BFS 而非 DFS 的認知策略：

```
傳統 DFS 方法（深度優先）：
使用者問題 → 猜測具體原因 → 深入追查 → 發現錯誤 → 回溯 → 重新猜測
              ↑_____________________________________________|
              （認知成本高：重複回溯）

Claude BFS 方法（廣度優先）：
使用者問題 → 建立全域理解 → 識別可能區域 → 逐步縮小範圍 → 精準定位
              ↓                  ↓                  ↓
           （建立索引）      （假設驗證）      （最小化搜尋空間）
```

#### 實際應用模式

**官方文檔建議**：

> "從廣泛的問題開始，然後縮小到特定領域"

**範例流程**：
```
1. 廣域理解："give me an overview of this codebase"
   → 建立心智地圖

2. 領域縮小："explain the main architecture patterns"
   → 識別關鍵模組

3. 精準定位："how is authentication handled?"
   → 深入特定功能

4. 執行追蹤："trace the login process from front-end to database"
   → 理解執行流
```

#### 認知優勢

| 階段 | 認知收益 | 避免的陷阱 |
|------|---------|-----------|
| **廣域理解** | 建立正確的問題空間 | 避免在錯誤假設上浪費時間 |
| **領域縮小** | 識別高價值探索方向 | 避免遍歷所有可能性 |
| **精準定位** | 聚焦認知資源 | 避免資訊過載 |
| **執行追蹤** | 驗證理解正確性 | 避免基於錯誤模型行動 |

### 執行流程追蹤

#### 認知方法：心智模擬

**Trace 方法的本質**：通過語言引導建立程式碼執行的心智模擬

```
官方範例：
"trace the login process from front-end to database"
```

**認知過程**：
```
1. 入口點識別 → 找到使用者觸發的事件
2. 呼叫鏈追蹤 → 函數呼叫的序列
3. 資料轉換 → 資料在層級間如何變化
4. 狀態變更 → 哪些狀態在何時被修改
5. 出口點確認 → 最終結果如何產生
```

**認知優勢**：
- **因果理解**：不僅知道「是什麼」，更理解「為什麼」
- **邊界識別**：清晰界定功能範圍和責任
- **依賴發現**：揭示隱含的模組依賴

### 領域語言使用

#### 認知原理：情境適配（Context Adaptation）

> "使用專案中的領域語言"（官方建議）

**為什麼領域語言重要？**

1. **降低語義摩擦**：
   - 使用專案術語 → 直接映射到程式碼實體
   - 使用通用術語 → 需要額外的語義轉換層

2. **提高溝通精確度**：
   ```
   通用語言："Find the user verification code"
   領域語言："Find the files that handle user authentication"
   ```
   領域語言版本直接使用專案中的「authentication」概念，更精準。

3. **利用既有心智模型**：
   - 專案團隊已建立共享的概念模型
   - 使用相同語言可激活這些模型

#### 實踐建議

| 情境 | 策略 | 範例 |
|------|------|------|
| **新專案** | 先要求詞彙表 | "provide a glossary of project-specific terms" |
| **熟悉專案** | 直接使用術語 | "update the AuthService's token refresh logic" |
| **跨專案** | 說明上下文 | "in this project, 'session' refers to..." |

---

## 程式碼庫學習方法論

### 概覽優先原則

#### 認知基礎：Schema Theory（基模理論）

人類理解複雜系統依賴**先建立基模（schema）**，再填充細節：

```
錯誤學習路徑：
程式碼檔案 A → 程式碼檔案 B → 程式碼檔案 C → ... → 試圖拼湊全貌
（認知過載，無法形成連貫理解）

正確學習路徑：
系統概覽 → 架構模式 → 關鍵模組 → 具體實現
   ↓           ↓           ↓           ↓
  基模      次級基模     細節掛載    深度理解
```

#### 官方推薦流程

```bash
# Step 1: 建立頂層基模
"give me an overview of this codebase"

# Step 2: 理解組織原則
"explain the main architecture patterns used here"

# Step 3: 識別核心實體
"what are the key data models?"

# Step 4: 追蹤具體流程
"how is authentication handled?"
```

### 漸進式深入

#### 認知策略：增量學習（Incremental Learning）

**核心原則**：每次查詢在前一次理解的基礎上建立，形成知識累積

```
漸進式深入模型：

Level 0: 黑盒理解
  "這是一個 Web 應用"

Level 1: 結構理解
  "前端（React）+ 後端（Node.js）+ 資料庫（PostgreSQL）"

Level 2: 模組理解
  "認證模組 + 使用者管理 + 資料處理 + API 層"

Level 3: 實現理解
  "JWT token 生成使用 HS256，有效期 24h"

Level 4: 執行理解
  "登入流程：驗證憑證 → 產生 token → 設定 cookie → 返回使用者資料"
```

#### 認知負荷管理

**Miller's Law**：人類工作記憶容量約 7±2 個項目

Claude Code 的漸進式方法自然符合這個限制：
- 每個層級專注於有限數量的高層概念
- 下一層級再展開其中一個概念
- 避免同時處理過多細節

### 模式識別

#### 認知過程：模式匹配與抽象

**官方建議**：
> "詢問專案中使用的編碼慣例和模式"

**為什麼模式重要？**

1. **認知經濟性**：
   - 識別出 MVC 模式 → 立即理解整個架構
   - 逐檔案分析 → 需要數十次分析才能得出相同理解

2. **預測能力**：
   - 知道專案使用 Repository Pattern
   - 可預測資料存取層的結構，無需查看每個檔案

3. **遷移學習**：
   - 模式是跨專案的共享知識
   - 識別模式可利用既有經驗

#### 模式識別清單

**應該尋找的模式**：

| 模式類型 | 查詢範例 | 認知收益 |
|---------|---------|---------|
| **架構模式** | "what architecture pattern is used?" | 理解整體組織 |
| **設計模式** | "what design patterns are in the auth module?" | 理解實現策略 |
| **編碼慣例** | "what are the naming conventions?" | 快速導航程式碼 |
| **錯誤處理** | "how does error handling work?" | 理解控制流 |
| **測試策略** | "what testing patterns are used?" | 理解品質保證 |

---

## 關鍵發現

### 1. 認知模式切換是核心能力

Claude Code 的方法論本質上是**多種認知模式的靈活切換**：

- **分析模式**（計畫模式）：理解與規劃
- **執行模式**（實作模式）：實現與驗證
- **探索模式**（BFS 策略）：發現與學習
- **追蹤模式**（Trace 方法）：因果推理

**關鍵洞察**：在正確的時間使用正確的認知模式，比單一模式的效率更重要。

### 2. 抽象層級管理是減少錯誤的關鍵

```
認知層級金字塔：

┌─────────────────────┐
│   戰略層（Why）      │  ← 計畫模式擅長
│   為什麼這樣設計？   │
├─────────────────────┤
│   戰術層（What）     │  ← 計畫模式 + 實作模式
│   做什麼？拆成哪些？ │
├─────────────────────┤
│   操作層（How）      │  ← 實作模式擅長
│   如何實現細節？     │
└─────────────────────┘
```

**核心原則**：在當前層級完成思考後再下沉，避免在操作層思考戰略問題，或在戰略層陷入實現細節。

### 3. 漸進式資訊揭示降低認知負荷

Claude Code 的工作流自然符合**漸進揭示原則**（Progressive Disclosure）：

- 不一次性載入所有資訊
- 根據當前任務需求獲取資訊
- 建立理解後再深入下一層

這與人類認知限制完美適配。

### 4. 領域語言是認知介面

使用專案領域語言不僅是溝通技巧，更是**認知介面設計**：

- 好的領域語言 = 好的心智模型
- 使用領域語言 = 激活專案特定的認知框架
- 一致的語言使用 = 減少認知摩擦

### 5. Trace 方法是因果理解的關鍵

程式碼理解的深度取決於因果理解：

```
層次 1：知道程式碼做什麼（What）
層次 2：知道程式碼如何做（How）
層次 3：知道為什麼這樣做（Why）← Trace 方法可達到此層
```

### 6. 模式識別是規模化學習的基礎

面對大型程式碼庫，**模式識別能力**決定學習速度：

- 高模式識別 → 快速建立高層理解
- 低模式識別 → 陷入逐行閱讀困境

Claude Code 的方法論明確鼓勵模式層級的思考。

### 7. 計畫模式的價值在於強制元認知

計畫模式的核心價值不僅是安全性，更是**強制進行元認知**：

- 迫使回答：「我真的理解問題了嗎？」
- 迫使回答：「有更好的方案嗎？」
- 迫使回答：「這個變更會影響什麼？」

在實作模式下，這些問題容易被「執行衝動」跳過。

---

## 建議

### 對 Multi-Agent Workflow 專案的應用建議

#### 1. 階段與認知模式對齊

```yaml
工作流階段的認知模式設計：

RESEARCH:
  cognitive_mode: 探索模式
  permission_mode: plan
  strategy: BFS 廣度優先
  focus: 建立全域理解

PLAN:
  cognitive_mode: 分析模式
  permission_mode: plan
  strategy: 模式識別 + 抽象設計
  focus: 戰略層決策

TASKS:
  cognitive_mode: 分解模式
  permission_mode: plan
  strategy: 依賴分析 + 粒度控制
  focus: 戰術層規劃

IMPLEMENT:
  cognitive_mode: 執行模式
  permission_mode: default
  strategy: TDD + 監督循環
  focus: 操作層實現

REVIEW:
  cognitive_mode: 驗證模式
  permission_mode: plan
  strategy: 多視角審查
  focus: 品質保障

VERIFY:
  cognitive_mode: 測試模式
  permission_mode: default
  strategy: 驗收標準檢查
  focus: 交付確認
```

**關鍵點**：RESEARCH、PLAN、TASKS、REVIEW 應使用計畫模式，保持分析性思考。

#### 2. 在 SubAgent 配置中明確認知任務

```json
{
  "name": "architecture-analyst",
  "description": "認知任務：使用 BFS 策略探索程式碼庫，識別架構模式，建立系統全域理解。use proactively when needing codebase understanding.",
  "permissionMode": "plan",
  "model": "sonnet",
  "tools": ["Read", "Glob", "Grep"]
}
```

在 description 中明確說明**認知任務類型**，幫助自動委派。

#### 3. 建立認知檢查點

在工作流關鍵轉換點加入**元認知問題**：

```yaml
PLAN → TASKS 轉換檢查點：
  questions:
    - "計劃是否在正確的抽象層級？"
    - "是否已識別關鍵架構模式？"
    - "依賴關係是否清晰？"

TASKS → IMPLEMENT 轉換檢查點：
  questions:
    - "任務粒度是否適合單次執行？"
    - "依賴順序是否明確？"
    - "驗收標準是否可測試？"
```

#### 4. 設計漸進式提示策略

**錯誤方式**：一次性給所有資訊
```
"分析程式碼庫並設計架構並分解任務並實作"
（認知過載）
```

**正確方式**：漸進式引導
```
Stage 1: "概覽程式碼庫，識別主要模組"
Stage 2: "針對認證模組，設計改進方案"
Stage 3: "將方案分解為可執行任務"
Stage 4: "實作第一個任務"
```

#### 5. 在 Hooks 中注入認知引導

```json
{
  "hooks": {
    "SubagentStart": [
      {
        "matcher": "task-decomposer",
        "hooks": ["remind_cognitive_mode.sh"]
      }
    ]
  }
}
```

```bash
# remind_cognitive_mode.sh
echo "認知模式：任務分解"
echo "抽象層級：戰術層（10-60 分鐘粒度）"
echo "策略：從里程碑分解為任務，識別依賴"
```

#### 6. 使用 Extended Thinking 處理複雜認知任務

在需要深度推理的階段明確啟用：

```yaml
PLAN 階段 prompt:
  "ultrathink: 分析目前架構，考慮三種可能的改進方案，
   評估每種方案的權衡，推薦最佳方案並說明理由。"
```

**適用情境**：
- 架構決策（多方案比較）
- 複雜除錯（多假設驗證）
- 風險分析（多維度評估）

#### 7. 建立領域詞彙表

在專案根目錄維護 `.claude/glossary.md`：

```markdown
# 專案術語表

## 工作流術語
- **Stage**：工作流的主要階段（RESEARCH, PLAN, TASKS, ...）
- **Perspective**：分析視角（architecture-analyst, ...）
- **Wave**：可並行執行的任務組

## 技術術語
- **DAG**：有向無環圖，表示任務依賴關係
- **TDD**：測試驅動開發
- **Supervision Loop**：監督循環，實作階段的審查機制
```

在 CLAUDE.md 中參考此詞彙表，建立一致的認知框架。

#### 8. 設計認知友善的輸出格式

**原則**：輸出應該符合人類的資訊處理方式

```yaml
# 好的輸出：結構化、漸進揭示
summary:
  - 核心結論（一句話）
  - 關鍵發現（3-5 點）

details:
  - 詳細分析
  - 支持證據

# 不好的輸出：平鋪直敘、無結構
[一大段文字...]
```

---

## 總結

Claude Code 的工作方法論體現了深刻的**認知科學原則**：

1. **認知模式切換**：在分析與執行間靈活切換
2. **抽象層級管理**：在正確的層級思考正確的問題
3. **漸進式資訊處理**：符合人類認知限制的學習策略
4. **模式驅動理解**：通過模式識別規模化學習
5. **因果推理能力**：通過 Trace 方法建立深度理解

對於 Multi-Agent Workflow 專案，關鍵是將這些認知原則**明確編碼**到工作流設計中：

- 階段設計反映認知模式轉換
- SubAgent 配置明確認知任務
- Hooks 提供認知引導
- 輸出格式符合人類資訊處理方式

**終極目標**：建立一個**認知友善**的多 Agent 協作框架，讓每個 Agent 在正確的認知模式下執行正確的任務，最大化整體智能表現。
